<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- Embed / Social Media Tags -->
    <meta property="og:title" content="Tetris but you are the RNG function" />
    <meta property="og:description" content="A game of Tetris played by AI with the user choosing incoming tetriminos" />
    <meta property="og:type" content="website" />
    <meta name="theme-color" content="#09090b" />
    
    <title>Tetris but you are the RNG function</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap");

      body {
        font-family: "JetBrains Mono", monospace;
        background-color: #09090b; /* Zinc 950 */
        color: #a1a1aa; /* Zinc 400 */
        overflow: hidden; /* Prevent scrolling */
      }

      /* Fix for Canvas Scaling/Blurring 
           We set the display size explicitly via CSS to match aspect ratio
           and ensure it doesn't overflow containers.
        */
      canvas {
        image-rendering: pixelated;
        max-width: 100%;
        /* Mobile: Restrict height to leave room for controls if needed */
        max-height: 60vh; 
        width: auto;
        height: auto;
        display: block;
      }

      /* Desktop: Scaled to ~70% of the previous 90vh setting */
      @media (min-width: 768px) {
        canvas {
          height: 63vh; 
          max-height: 63vh;
          width: auto; /* Maintains aspect ratio */
        }
      }

      /* Updated scrollbar for both vertical (queue) and horizontal if needed */
      .queue-scroll::-webkit-scrollbar {
        height: 4px;
        width: 4px; /* Added width for vertical scrolling */
      }
      .queue-scroll::-webkit-scrollbar-track {
        background: #18181b;
      }
      .queue-scroll::-webkit-scrollbar-thumb {
        background: #3f3f46;
        border-radius: 2px;
      }

      /* Button Styling */
      .btn-control {
        background-color: #18181b;
        border: 1px solid #27272a;
        transition: all 0.1s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }
      .btn-control:hover {
        background-color: #27272a;
        border-color: #52525b;
      }
      .btn-control:active {
        transform: scale(0.96);
      }

      /* Mini Grids for Queue & Buttons */
      .mini-grid {
        display: grid;
        gap: 1px;
        pointer-events: none; /* Let clicks pass to button */
      }
      .mini-cell {
        width: 8px; /* Increased base size */
        height: 8px; /* Increased base size */
        border-radius: 1px;
      }
      /* Mobile adjustment for tiny cells */
      @media (min-width: 768px) {
        .mini-cell {
          width: 10px; /* Increased desktop size */
          height: 10px; /* Increased desktop size */
        }
      }

      .queue-item {
        animation: slideLeft 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }
      @keyframes slideLeft {
        from {
          transform: translateX(20px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col md:flex-row items-center justify-center px-4 py-2 md:px-6 md:py-3 gap-6 md:gap-10"
  >
    <!-- Left: Game Area -->
    <div class="flex flex-col items-center gap-4 shrink-0">
      <!-- Header for Mobile -->
      <h1
        class="md:hidden text-xs font-bold text-zinc-500 tracking-widest uppercase"
      >
        Tetris but you are the RNG
      </h1>

      <div class="relative group">
        <!-- Canvas Container with specific border sizing -->
        <div
          class="border-2 border-zinc-800 p-1 bg-zinc-900 shadow-2xl rounded-sm"
        >
          <!-- FIXED: Height increased to 480 to match 20 rows * 24px -->
          <canvas
            id="gameCanvas"
            width="240"
            height="480"
            class="bg-black"
          ></canvas>
        </div>

        <!-- Stats Panel (Desktop) -->
        <div class="absolute top-0 -left-32 text-right hidden md:block w-28">
          <div class="mb-6">
            <h1 class="text-sm font-bold text-zinc-300 leading-tight mb-1">
              TETRIS<br /><span class="text-xs text-zinc-600 font-normal"
                >BUT YOU ARE THE RNG FUNCTION</span
              >
            </h1>
          </div>

          <div class="space-y-4">
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
              >
                Score
              </div>
              <div id="scoreDisplay" class="text-xl text-white font-mono">
                0
              </div>
            </div>
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
              >
                Lines
              </div>
              <div id="linesDisplay" class="text-xl text-white font-mono">
                0
              </div>
            </div>
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
              >
                Level
              </div>
              <div id="levelDisplay" class="text-xl text-yellow-500 font-mono">
                0
              </div>
            </div>
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest mt-2"
              >
                AI Mode
              </div>
              <div id="aiStateDisplay" class="text-xs text-blue-400 font-mono font-bold uppercase">
                CALM
              </div>
            </div>
          </div>
        </div>
      </div>

      <div
        id="gameStatus"
        class="h-6 text-sm font-bold tracking-widest text-zinc-500 uppercase flex items-center gap-2"
      >
        WAITING FOR INPUT
      </div>
    </div>

    <!-- Right: Controls -->
    <!-- Changed max-w-sm to max-w-md for wider UI -->
    <div class="flex flex-col w-full max-w-md gap-4">
      <!-- Level Select & Mobile Stats -->
      <div class="flex justify-between items-end">
        <!-- Mobile Stats -->
        <div class="flex gap-4 md:hidden text-xs w-full">
          <div>
            <span class="text-zinc-600">LVL</span>
            <span id="mobLevel" class="text-white">0</span>
          </div>
          <div>
            <span class="text-zinc-600">LNS</span>
            <span id="mobLines" class="text-white">0</span>
          </div>
          <!-- Added Mobile AI Mode Indicator -->
          <div class="ml-auto">
             <span class="text-zinc-600">AI:</span>
             <span id="mobAiState" class="text-blue-400 font-mono font-bold uppercase">CALM</span>
          </div>
        </div>

        <div class="flex items-center gap-2 ml-auto hidden md:flex">
          <!-- Reset Button Moved Here -->
          <button
            onclick="resetGame()"
            class="h-6 px-2 rounded bg-red-900/20 border border-red-900/50 text-red-500 text-[10px] font-bold uppercase hover:bg-red-900/40 transition-colors"
          >
            RST
          </button>
          <div class="w-px h-4 bg-zinc-800 mx-1"></div>
          <label class="text-[10px] font-bold text-zinc-600 uppercase"
            >Start Level</label
          >
          <select
            id="startLevel"
            onchange="resetGame()"
            class="bg-zinc-900 border border-zinc-700 text-zinc-300 text-xs rounded px-2 py-1 outline-none focus:border-blue-500"
          >
            <option value="0">00</option>
            <option value="1">01</option>
            <option value="2">02</option>
            <option value="3">03</option>
            <option value="4">04</option>
            <option value="5">05</option>
            <option value="6">06</option>
            <option value="7">07</option>
            <option value="8">08</option>
            <option value="9">09</option>
          </select>
        </div>
      </div>

      <!-- Queue Display -->
      <!-- UPDATED: min-h instead of fixed height, allowing vertical growth up to a limit -->
      <div
        class="bg-zinc-900/80 border border-zinc-800 p-3 rounded-sm min-h-[7rem] max-h-[40vh] flex flex-col shadow-inner transition-all duration-200"
      >
        <div class="flex justify-between items-center mb-2 shrink-0">
          <span
            class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
            >Next Queue</span
          >
          <span id="queueCount" class="text-[10px] text-zinc-500">0</span>
        </div>

        <!-- UPDATED: flex-wrap to allow multiple rows, overflow-y-auto for vertical scrolling if needed -->
        <div
          id="visualQueue"
          class="queue-scroll flex-1 flex flex-wrap gap-2 overflow-y-auto content-start px-1"
        >
          <div
            id="emptyQueueMsg"
            class="w-full text-center text-xs text-zinc-700 italic"
          >
            Tap buttons below...
          </div>
        </div>
      </div>

      <!-- Input Grid -->
      <div class="grid grid-cols-4 gap-2" id="controlsGrid">
        <!-- Buttons generated by JS -->
      </div>

      <div class="flex flex-col items-center mt-2">
        <div class="text-center text-[10px] text-zinc-700">
          AI plays automatically using your pieces
        </div>
        <div class="text-center text-[10px] text-zinc-800 mt-1">
          Use Keyboard: SZTLJIO or 1-7 (Space to Pause)
        </div>
      </div>
    </div>

    <script>
      /**
       * Tetris: You are the RNG
       * * Updates:
       * - Fixed Orange L-Piece definition (was missing a block).
       * - Changed Queue to a wrapping grid that expands vertically.
       * - Added "Tetris Planning" AI mode to look ahead for Longbois.
       * - Added Beam Search lookahead (depth 5) for smarter general moves.
       * - Increased Beam Width to 15 for deeper strategic planning.
       * - Added Flatness heuristic to encourage cleaner stacking.
       * - REMOVED Lookahead Limit: Now scans the ENTIRE queue.
       * - FIXED Beam Search Scoring: Swaps weights dynamically for the I-piece based on well depth.
       * - ADDED Pause functionality and rearranged controls.
       * - FIXED Crash on large queues: Added simulation horizon (MAX_SIM_DEPTH = 20).
       * - IMPROVED Local Fit: Added Row and Column Transition heuristics.
       * - GLOBAL Keydown: Keyboard works anywhere on page.
       * - UI UPDATE: Spacebar pause & "LOCKED IN" display.
       * - FEATURE: "LOCKED IN" persistence with STRICT Tetris verification.
       * - UI FIX: Added AI Mode display for Mobile.
       * - OPTIMIZATION: Memoized plan to prevent re-simulation lag on drop.
       */

      // --- Configuration ---
      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 24;
      const AI_THINK_DELAY = 50;
      const BEAM_WIDTH = 25; 
      const MAX_SIM_DEPTH = 20; // Refined limit for optimal performance vs planning

      // Base speeds (ms per tick) mimicking NES curve somewhat adapted for AI animation
      // Level 0 is slow-ish, Level 9 is very snappy.
      const SPEEDS = [
        200, // Lvl 0
        180, // Lvl 1
        160, // Lvl 2
        140, // Lvl 3
        120, // Lvl 4
        100, // Lvl 5
        80, // Lvl 6
        60, // Lvl 7
        40, // Lvl 8
        20, // Lvl 9 (Hyper)
      ];

      // --- Shapes & Colors ---
      const SHAPES = {
        I: {
          color: "#06b6d4",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [2, 0],
          ],
          width: 4,
          height: 1,
        }, // Cyan (Tailwind cyan-500)
        J: {
          color: "#3b82f6",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [1, 1],
          ],
          width: 3,
          height: 2,
        }, // Blue (blue-500)
        L: {
          color: "#f97316",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0], // FIXED: Added missing block
            [-1, 1],
          ],
          width: 3,
          height: 2,
        }, // Orange (orange-500)
        O: {
          color: "#eab308",
          blocks: [
            [0, 0],
            [1, 0],
            [0, 1],
            [1, 1],
          ],
          width: 2,
          height: 2,
        }, // Yellow (yellow-500)
        S: {
          color: "#22c55e",
          blocks: [
            [0, 0],
            [1, 0],
            [0, 1],
            [-1, 1],
          ],
          width: 3,
          height: 2,
        }, // Green (green-500)
        T: {
          color: "#a855f7",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [0, 1],
          ],
          width: 3,
          height: 2,
        }, // Purple (purple-500)
        Z: {
          color: "#ef4444",
          blocks: [
            [0, 0],
            [-1, 0],
            [0, 1],
            [1, 1],
          ],
          width: 3,
          height: 2,
        }, // Red (red-500)
      };

      const KEY_MAP = {
        1: "I",
        2: "O",
        3: "T",
        4: "S",
        5: "Z",
        6: "J",
        7: "L",
        i: "I",
        o: "O",
        t: "T",
        s: "S",
        z: "Z",
        j: "J",
        l: "L",
      };

      // --- Game State ---
      let board = [];
      let pieceQueue = [];
      let currentPiece = null;
      let score = 0;
      let lines = 0;
      let level = 0;
      let startLevel = 0;
      let gameOver = false;
      let animationId = null;
      let isPaused = false; // New Pause State
      
      // Locking State
      let lockedMoves = [];
      let isLocked = false;
      let lastQueueHash = ""; // For tracking changes to queue to invalidate plan

      // AI State
      let aiTarget = null;
      let lastAiActionTime = 0;
      let isAiActing = false;

      // --- Canvas ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // --- Initialization ---
      function init() {
        // Cancel old loop if exists
        if (animationId) cancelAnimationFrame(animationId);

        // Reset core vars
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        pieceQueue = [];
        currentPiece = null;
        score = 0;
        lines = 0;
        gameOver = false;
        isAiActing = false;
        aiTarget = null;
        isPaused = false; // Reset pause
        
        // Reset Lock
        lockedMoves = [];
        isLocked = false;
        lastQueueHash = "";

        // Get start level
        const select = document.getElementById("startLevel");
        startLevel = parseInt(select.value, 10);
        level = startLevel;

        updateUI();
        updateQueueUI();
        updateStatus("Waiting for Input");
        updateAIStatus("CALM", "text-blue-400");
        
        // Reset pause button visual if exists
        const pBtn = document.getElementById("pauseBtn");
        if(pBtn) {
            pBtn.classList.remove("bg-yellow-900/30", "text-yellow-500", "border-yellow-700");
            pBtn.classList.add("bg-zinc-800", "text-zinc-400", "border-zinc-700");
            pBtn.innerText = "PAUSE";
        }

        // Start loop
        gameLoop();
      }

      function updateAIStatus(text, colorClass) {
          const el = document.getElementById("aiStateDisplay");
          const mobEl = document.getElementById("mobAiState");
          if(el) {
              el.innerText = text;
              el.className = `text-xs ${colorClass} font-mono font-bold uppercase ${text === "LOCKED IN" || text === "PANIC" ? "animate-pulse" : ""}`;
          }
          if(mobEl) {
              mobEl.innerText = text;
              mobEl.className = `text-xs ${colorClass} font-mono font-bold uppercase ${text === "LOCKED IN" || text === "PANIC" ? "animate-pulse" : ""}`;
          }
      }

      function togglePause() {
        isPaused = !isPaused;
        const btn = document.getElementById("pauseBtn");
        if (btn) {
            if (isPaused) {
                btn.classList.add("bg-yellow-900/30", "text-yellow-500", "border-yellow-700");
                btn.classList.remove("bg-zinc-800", "text-zinc-400", "border-zinc-700");
                btn.innerText = "RESUME"; // Play/Resume
                updateStatus("QUEUE BUILDING PAUSED", "text-yellow-500");
            } else {
                btn.classList.remove("bg-yellow-900/30", "text-yellow-500", "border-yellow-700");
                btn.classList.add("bg-zinc-800", "text-zinc-400", "border-zinc-700");
                btn.innerText = "PAUSE";
                updateStatus("RESUMING...");
            }
        }
      }

      // Generate the control buttons dynamically
      function initControls() {
        const grid = document.getElementById("controlsGrid");
        // New Layout: Row 1: J L S Z | Row 2: O T I [PAUSE]
        const order = ["J", "L", "S", "Z", "O", "T", "I"];

        grid.innerHTML = "";

        order.forEach((type) => {
          const btn = document.createElement("button");
          btn.className = "btn-control h-12 md:h-14 rounded-sm relative";
          btn.onclick = () => addPiece(type);
          btn.title = `Add ${type} Piece`;
          btn.appendChild(createMiniGrid(type));
          grid.appendChild(btn);
        });

        // Create Pause Button
        const pauseBtn = document.createElement("button");
        pauseBtn.id = "pauseBtn";
        pauseBtn.onclick = togglePause;
        pauseBtn.className = "btn-control h-12 md:h-14 rounded-sm border border-zinc-700 bg-zinc-800 text-zinc-400 hover:bg-zinc-700 font-bold text-[10px] uppercase transition-colors flex items-center justify-center";
        pauseBtn.innerText = "PAUSE";
        grid.appendChild(pauseBtn);
      }

      // Helper to create HTML representation of a piece
      function createMiniGrid(type) {
        const shape = SHAPES[type];
        const wrapper = document.createElement("div");
        wrapper.className = "mini-grid";

        // Calculate grid dimensions based on shape
        // Center the piece in a 4x2 or 4x3 grid
        const w = 4;
        const h = type === "I" ? 1 : 2; // flatten for button

        wrapper.style.gridTemplateColumns = `repeat(${w}, 1fr)`;

        // Create a 4xN grid map
        const gridMap = Array(w * 2).fill(0); // ample space

        // Map blocks to the grid. Offset to center.
        // Base offsets to make them look nice in the button
        let offsetX = 1;
        let offsetY = 0;

        if (type === "I") {
          offsetX = 1;
          offsetY = 0;
        }
        if (type === "O") {
          offsetX = 1;
          offsetY = 0;
        }
        if (
          type === "T" ||
          type === "S" ||
          type === "Z" ||
          type === "J" ||
          type === "L"
        ) {
          offsetX = 1;
          offsetY = 0;
        }

        shape.blocks.forEach(([x, y]) => {
          // block coords are relative to pivot (0,0)
          // map to flat array index
          const gx = x + offsetX;
          const gy = y + offsetY;
          const idx = gy * w + gx;
          if (idx >= 0 && idx < gridMap.length) {
            gridMap[idx] = 1;
          }
        });

        // Build DOM
        gridMap.forEach((active) => {
          const cell = document.createElement("div");
          cell.className = "mini-cell";
          if (active) {
            cell.style.backgroundColor = shape.color;
            cell.style.boxShadow = "inset 0 0 2px rgba(0,0,0,0.3)";
          } else {
            cell.style.backgroundColor = "transparent";
          }
          wrapper.appendChild(cell);
        });

        return wrapper;
      }

      // --- Logic ---

      function addPiece(type) {
        if (gameOver) init();
        pieceQueue.push(type);
        // Queue changed, plan might be stale or need extension
        // We generally invalidate plan if user adds pieces because it might open up better opportunities
        // BUT if we are locked in, maybe we keep it? 
        // No, let's just let the planner re-run on next spawn.
        // Actually, if we are locked in, we want to STICK to the plan unless the board state changes unexpectedly.
        // Adding pieces to the END of queue shouldn't invalidate the CURRENT plan for the front of the queue.
        // So we only update hash, logic will handle re-calc if needed.
        updateQueueUI();
      }

      function updateStatus(msg, colorClass = "text-zinc-500") {
        const el = document.getElementById("gameStatus");
        el.innerHTML = msg;
        el.className = `h-6 text-sm font-bold tracking-widest uppercase flex items-center gap-2 ${colorClass}`;
      }

      // Main Game Loop
      function gameLoop(time = 0) {
        if (gameOver) return;

        // 1. Spawning - blocked if Paused
        if (!currentPiece && !isAiActing && !isPaused) {
          if (pieceQueue.length > 0) {
            spawnPiece();
          } else {
            updateStatus("Waiting for Input");
          }
        }

        // 2. AI Animation/Logic - blocked if Paused
        if (currentPiece && isAiActing && aiTarget && !isPaused) {
          // Determine speed based on level (clamped to max index)
          const speedIndex = Math.min(level, SPEEDS.length - 1);
          const interval = SPEEDS[speedIndex];

          if (time - lastAiActionTime > interval) {
            performAiStep();
            lastAiActionTime = time;
          }
        }

        // 3. Render
        render();
        animationId = requestAnimationFrame(gameLoop);
      }

      function spawnPiece() {
        const type = pieceQueue.shift();
        updateQueueUI();

        updateStatus(
          `Processing <span style="color:${SHAPES[type].color}">${type}</span>...`,
          "text-zinc-300"
        );

        currentPiece = {
          type: type,
          x: 4,
          y: 0,
          shape: JSON.parse(JSON.stringify(SHAPES[type].blocks)),
          rotationState: 0,
          color: SHAPES[type].color,
        };

        if (
          checkCollision(currentPiece.x, currentPiece.y, currentPiece.shape)
        ) {
          gameOver = true;
          updateStatus("Game Over", "text-red-500");
          return;
        }

        setTimeout(() => {
          const move = findBestMove(board, currentPiece);
          if (move) {
            aiTarget = move;
            isAiActing = true;
          } else {
            aiTarget = { x: currentPiece.x, rotation: 0 };
            isAiActing = true;
          }
        }, AI_THINK_DELAY);
      }

      function performAiStep() {
        if (!currentPiece) return;

        // Rotation
        if (currentPiece.rotationState !== aiTarget.rotation) {
          const rotated = rotatePiece(currentPiece);
          if (rotated) {
            currentPiece.rotationState = (currentPiece.rotationState + 1) % 4;
          } else {
            // If rotation failed (blocked), force skip to X movement to prevent infinite loop
            // In a real scenario, this means AI plan is invalid, but we just fall through
          }
          return;
        }

        // X Movement
        if (currentPiece.x !== aiTarget.x) {
          const direction = aiTarget.x > currentPiece.x ? 1 : -1;
          if (
            !checkCollision(
              currentPiece.x + direction,
              currentPiece.y,
              currentPiece.shape
            )
          ) {
            currentPiece.x += direction;
            return;
          }
        }

        // Drop
        if (
          !checkCollision(
            currentPiece.x,
            currentPiece.y + 1,
            currentPiece.shape
          )
        ) {
          currentPiece.y++;
        } else {
          lockPiece();
        }
      }

      function rotatePiece(piece) {
        const newShape = piece.shape.map(([x, y]) => [-y, x]);
        // Wall kick
        if (checkCollision(piece.x, piece.y, newShape)) {
          if (!checkCollision(piece.x - 1, piece.y, newShape)) piece.x -= 1;
          else if (!checkCollision(piece.x + 1, piece.y, newShape))
            piece.x += 1;
          else return false; // Fail
        }
        piece.shape = newShape;
        return true; // Success
      }

      function checkCollision(x, y, shape, testBoard = board) {
        for (const [bx, by] of shape) {
          const nx = x + bx;
          const ny = y + by;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (ny >= 0 && testBoard[ny][nx]) return true;
        }
        return false;
      }

      function lockPiece() {
        for (const [bx, by] of currentPiece.shape) {
          const ny = currentPiece.y + by;
          const nx = currentPiece.x + bx;
          if (ny >= 0) {
            board[ny][nx] = currentPiece.color;
          }
        }
        clearLines();
        currentPiece = null;
        isAiActing = false;
        aiTarget = null;
      }

      function clearLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every((cell) => cell !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++;
          }
        }
        if (linesCleared > 0) {
          lines += linesCleared;
          // Standard NES scoring
          const multipliers = [0, 40, 100, 300, 1200];
          score += multipliers[linesCleared] * (level + 1);

          // Level up logic (every 10 lines)
          const oldLevel = level;
          level = startLevel + Math.floor(lines / 10);

          updateUI();
        }
      }

      // --- AI Evaluation System ---
      
      // Calm: Standard play, efficient, tries to keep things low and flat
      const BASE_WEIGHTS = {
        aggregateHeight: -0.5,
        completeLines: 0.76, 
        holes: -0.6,      // High penalty to prevent swiss cheese with S/Z
        bumpiness: -0.25, // Keep it relatively flat
        wells: -0.15,     // Slight penalty for deep 1-wide wells
        rowTransitions: -0.5, // Stronger penalty for jagged rows (fixes bad L piece)
        colTransitions: -0.5  // Stronger penalty for jagged cols
      };

      // Panic: Board is too high! Burn lines at all costs!
      const PANIC_WEIGHTS = {
        aggregateHeight: -0.9, // Lower the board!
        completeLines: 3.0,    // BURN LINES NOW!
        holes: -0.2,           // Who cares about holes, we are dying!
        bumpiness: -0.2,
        wells: -0.1,
        rowTransitions: -0.2,
        colTransitions: -0.2
      };
      
      // Tetris Build: Stacking up!
      const TETRIS_BUILD_WEIGHTS = {
        aggregateHeight: 0.0, 
        completeLines: -4.0,  // Penalty: DO NOT burn lines with non-I pieces
        holes: -0.8,          // Be very clean
        bumpiness: -0.3,      // Slightly stronger bumpiness check
        flatness: -0.3,       // Relaxed flatness to allow "building up" with L/J
        wells: 0.0,           
        wellPreservation: -12.0, // Huge penalty for covering the target well
        rowTransitions: -0.6, // VERY Strict solidity needed
        colTransitions: -0.6
      };

      // Tetris Execute: Finish Him!
      const TETRIS_EXECUTE_WEIGHTS = {
        aggregateHeight: 0.0,
        completeLines: 100.0, // MASSIVE reward for clearing lines (ideally 4)
        holes: -0.2,
        bumpiness: -0.2,
        wells: 0.0,
        wellPreservation: 0.0, // Ignore well safety, we are dropping the I!
        rowTransitions: -0.2,
        colTransitions: -0.2
      };

      // --- Beam Search Implementation ---
      function getValidMoves(grid, pieceType) {
        const moves = [];
        const shapeDef = SHAPES[pieceType];
        // Standard shape blocks at relative (0,0)
        const baseShape = JSON.parse(JSON.stringify(shapeDef.blocks));
        const rotations = pieceType === "O" ? 1 : 4;

        for (let r = 0; r < rotations; r++) {
          // Generate rotated shape
          let shape = JSON.parse(JSON.stringify(baseShape));
          for (let i = 0; i < r; i++) shape = shape.map(([x, y]) => [-y, x]);

          // Scan all x positions
          for (let x = -3; x < COLS + 3; x++) {
            // Check if valid at top spawn (approximate)
            if (!checkCollision(x, 0, shape, grid)) {
              // Find drop height
              let y = 0;
              while (!checkCollision(x, y + 1, shape, grid)) y++;

              // Create Resulting Grid
              const tempGrid = grid.map((row) => [...row]);
              let validLock = true;
              for (const [bx, by] of shape) {
                const ny = y + by;
                const nx = x + bx;
                if (ny < 0 || ny >= ROWS || nx < 0 || nx >= COLS) validLock = false;
                else tempGrid[ny][nx] = 1;
              }

              if (validLock) {
                moves.push({ x, rotation: r, grid: tempGrid });
              }
            }
          }
        }
        return moves;
      }

      function beamSearch(initialGrid, pieceTypes, targetWellCol, currentMode) {
        // Candidates: { grid, firstMove, score, path, maxLinesCleared }
        let candidates = [{ 
           grid: initialGrid, 
           firstMove: null,
           path: [], 
           score: -Infinity,
           maxLinesCleared: 0
        }];

        for (let i = 0; i < pieceTypes.length; i++) {
            const type = pieceTypes[i];
            let nextCandidates = [];
            
            // Expand each candidate
            for (const cand of candidates) {
                // Determine weights for THIS specific candidate path based on its own state
                let stepWeights = BASE_WEIGHTS;
                let stepWellCol = -1;

                if (currentMode === "PANIC") {
                    stepWeights = PANIC_WEIGHTS;
                } else if (currentMode === "PLOTTING") {
                    // Smart Check: Is the well deep enough to EXECUTE?
                    let candColHeights = new Array(COLS).fill(0);
                    for(let x=0; x<COLS; x++) {
                       for(let y=0; y<ROWS; y++) {
                           if(cand.grid[y][x] !== 0) {
                               candColHeights[x] = ROWS - y;
                               break;
                           }
                       }
                    }
                    
                    let minWallHeight = ROWS;
                    for(let c=0; c<COLS; c++) {
                        if (c !== targetWellCol) minWallHeight = Math.min(minWallHeight, candColHeights[c]);
                    }
                    const candWellDepth = minWallHeight - candColHeights[targetWellCol];

                    if (type === "I" && candWellDepth >= 4) {
                        // If we are placing an I-piece AND the well is deep enough -> EXECUTE!
                        stepWeights = TETRIS_EXECUTE_WEIGHTS;
                        stepWellCol = -1; 
                    } else {
                        // Otherwise (not I-piece OR well too shallow) -> BUILD!
                        stepWeights = TETRIS_BUILD_WEIGHTS;
                        stepWellCol = targetWellCol;
                    }
                } else {
                    stepWeights = BASE_WEIGHTS;
                }

                const moves = getValidMoves(cand.grid, type);
                
                // If no moves possible (game over in sim), skip this candidate
                if (moves.length === 0) continue;

                for (const move of moves) {
                    const score = evaluateGrid(move.grid, stepWeights, stepWellCol);
                    
                    // Check for lines cleared in this step
                    let linesInStep = 0;
                    for(let r=0; r<ROWS; r++) {
                        if (move.grid[r].every(c => c !== 0)) linesInStep++;
                    }

                    const thisMove = { x: move.x, rotation: move.rotation };

                    nextCandidates.push({
                        grid: move.grid,
                        firstMove: i === 0 ? thisMove : cand.firstMove,
                        path: [...cand.path, thisMove], 
                        score: cand.score !== -Infinity ? cand.score + score : score,
                        maxLinesCleared: Math.max(cand.maxLinesCleared, linesInStep)
                    });
                }
            }

            // Sort and prune (Keep top K)
            nextCandidates.sort((a, b) => b.score - a.score);
            candidates = nextCandidates.slice(0, BEAM_WIDTH);
            
            // Optimization: If no valid candidates, break
            if (candidates.length === 0) break;
        }

        // Return best candidate (with full path)
        return candidates.length > 0 ? candidates[0] : null;
      }

      function findBestMove(grid, piece) {
        let bestMove = null;
        
        // Generate Queue Hash to detect changes
        const currentQueueHash = piece.type + "|" + pieceQueue.join("");

        // Check Locked Plan FIRST
        if (isLocked && lockedMoves.length > 0) {
            // Check if queue has changed significantly (e.g. user added pieces that might offer better path?)
            // Actually, if we are locked in, we stick to plan unless user ADDS pieces.
            // But if user adds pieces, we might want to re-evaluate.
            // HOWEVER, user requested to make it better at storing plans to avoid freezing.
            // So we TRUST the plan unless the head of the queue doesn't match our expectation (which shouldn't happen)
            // or if we finished the plan.
            
            // NOTE: Beam search path includes current piece. 
            // So lockedMoves[0] corresponds to the NEXT piece in queue.
            // We assume the game state follows the plan.
            
            updateAIStatus("LOCKED IN", "text-purple-500");
            
            const next = lockedMoves.shift();
            if (lockedMoves.length === 0) isLocked = false;
            return next;
        }
        
        // If empty plan, ensure unlocked
        if (lockedMoves.length === 0) isLocked = false;

        // 1. Determine Board State & Weights
        let maxHeight = 0;
        let totalHoles = 0;
        
        // Quick Board Scan
        const colHeights = new Array(COLS).fill(0);
        for(let x=0; x<COLS; x++) {
           let colHoles = 0;
           let blockFound = false;
           for(let y=0; y<ROWS; y++) {
               if(grid[y][x] !== 0) {
                   const h = ROWS - y;
                   colHeights[x] = h;
                   maxHeight = Math.max(maxHeight, h);
                   blockFound = true;
               } else if (blockFound) {
                   colHoles++;
               }
           }
           totalHoles += colHoles;
        }
        
        // Find Best Well
        let targetWellCol = 9; 
        if (colHeights[0] < colHeights[9] - 2) {
             targetWellCol = 0;
        }
        
        // Logic Branching
        let mode = "CALM";
        
        const isPanic = maxHeight > 12;
        const iIndex = pieceQueue.indexOf("I");
        // Look through ENTIRE queue now for STRATEGY
        const hasLongboi = iIndex !== -1; 
        const isSafe = maxHeight < 14 && totalHoles < 5;

        if (isPanic) {
            mode = "PANIC";
        } else if (hasLongboi && isSafe) {
            // Estimation Logic
            let minWallHeight = ROWS;
            for(let c=0; c<COLS; c++) {
                if (c !== targetWellCol) minWallHeight = Math.min(minWallHeight, colHeights[c]);
            }
            const currentWellDepth = minWallHeight - colHeights[targetWellCol];
            const rowsNeeded = Math.max(0, 4 - currentWellDepth);
            const blocksNeeded = rowsNeeded * 9; 
            const blocksAvailable = iIndex * 4;
            
            if (rowsNeeded === 0 || blocksAvailable >= blocksNeeded) {
                 mode = "PLOTTING";
            } else {
                 mode = "CALM";
            }
        }
        
        // Update UI debug
        if (mode === "PANIC") {
            updateAIStatus(mode, "text-red-500");
        } else if (mode === "PLOTTING") {
            updateAIStatus("PLOTTING...", "text-purple-400");
        } else {
            updateAIStatus(mode, "text-blue-400");
        }

        // 2. Perform Lookahead Beam Search
        // We use the queue up to the I piece if PLOTTING, otherwise standard limited depth
        let piecesToLookAhead = [];
        
        if (mode === "PLOTTING") {
             // Simulate exactly until the I piece to capture the full Tetris plan
             piecesToLookAhead = [piece.type, ...pieceQueue.slice(0, iIndex + 1)];
             // Cap strictly at something reasonable if queue is insanely long
             if (piecesToLookAhead.length > 25) {
                 piecesToLookAhead = piecesToLookAhead.slice(0, 25);
             }
        } else {
             // Standard behavior
             piecesToLookAhead = [piece.type, ...pieceQueue].slice(0, MAX_SIM_DEPTH);
        }
        
        if (piecesToLookAhead.length > 0) {
             const result = beamSearch(grid, piecesToLookAhead, targetWellCol, mode);
             if (result) {
                 bestMove = result.firstMove;
                 
                 // Smart Locking:
                 // Only lock if we are PLOTTING a tetris AND the plan actually achieves >= 4 lines cleared
                 if (mode === "PLOTTING") {
                     if (result.path.length > 1 && result.maxLinesCleared >= 4) {
                         // Cache the plan!
                         lockedMoves = result.path.slice(1);
                         isLocked = true;
                         lastQueueHash = currentQueueHash; 
                         updateAIStatus("LOCKED IN", "text-purple-500");
                     }
                 }
             }
        }
        
        // Fallback if deep search failed
        if (!bestMove) {
             const moves = getValidMoves(grid, piece.type);
             let bestScore = -Infinity;
             for (const m of moves) {
                 const s = evaluateGrid(m.grid, PANIC_WEIGHTS, -1);
                 if (s > bestScore) {
                     bestScore = s;
                     bestMove = { x: m.x, rotation: m.rotation };
                 }
             }
        }

        return bestMove;
      }

      function evaluateGrid(grid, weights, targetWellCol = -1) {
        let aggH = 0,
          lines = 0,
          holes = 0,
          bump = 0,
          wells = 0,
          wellCover = 0, // Penalty for covering our designated Tetris well
          rowTrans = 0,
          colTrans = 0;
          
        const heights = new Array(COLS).fill(0);

        // Calculate Column Heights & Aggregate Height
        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS; y++) {
            if (grid[y][x] !== 0) {
              heights[x] = ROWS - y;
              break;
            }
          }
        }
        aggH = heights.reduce((a, b) => a + b, 0);

        // Count Lines
        for (let y = 0; y < ROWS; y++) {
          if (grid[y].every((c) => c !== 0)) lines++;
        }

        // Count Holes
        for (let x = 0; x < COLS; x++) {
          let block = false;
          for (let y = 0; y < ROWS; y++) {
            if (grid[y][x] !== 0) block = true;
            else if (block && grid[y][x] === 0) holes++;
          }
        }

        // Count Bumpiness
        for (let x = 0; x < COLS - 1; x++)
          bump += Math.abs(heights[x] - heights[x + 1]);

        // Count Wells (Deep 1-wide valleys)
        for (let x = 0; x < COLS; x++) {
           // If we are targeting a specific well, check if we covered it
           if (targetWellCol !== -1 && x === targetWellCol) {
               wellCover += heights[x]; 
           }

           const hLeft = x === 0 ? 20 : heights[x-1];
           const hRight = x === COLS - 1 ? 20 : heights[x+1];
           const h = heights[x];
           
           if (h < hLeft && h < hRight) {
             const depth = Math.min(hLeft, hRight) - h;
             if (depth >= 2) {
               wells += depth;
             }
           }
        }

        // NEW: Row Transitions
        if (weights.rowTransitions) {
            for (let y = 0; y < ROWS; y++) {
                let prev = 1; // Left wall is "filled"
                for (let x = 0; x < COLS; x++) {
                    const curr = grid[y][x] !== 0 ? 1 : 0;
                    if (curr !== prev) rowTrans++;
                    prev = curr;
                }
                if (prev === 0) rowTrans++; // Right wall is "filled"
            }
        }

        // NEW: Column Transitions
        if (weights.colTransitions) {
            for (let x = 0; x < COLS; x++) {
                let prev = 0; // Top is empty
                for (let y = 0; y < ROWS; y++) {
                    const curr = grid[y][x] !== 0 ? 1 : 0;
                    if (curr !== prev) colTrans++;
                    prev = curr;
                }
                if (prev === 0) colTrans++; // Bottom is filled
            }
        }

        let score = weights.aggregateHeight * aggH +
          weights.completeLines * lines +
          weights.holes * holes +
          weights.bumpiness * bump +
          (weights.wells || 0) * wells + 
          (weights.rowTransitions || 0) * rowTrans +
          (weights.colTransitions || 0) * colTrans;
          
        // Apply special well preservation penalty
        if (targetWellCol !== -1 && weights.wellPreservation) {
            score += weights.wellPreservation * wellCover;
        }

        // Calculate Flatness (Standard Deviation-ish) for Plotting
        if (weights.flatness) {
           let sumH = 0;
           let count = 0;
           for (let x = 0; x < COLS; x++) {
               if (x !== targetWellCol) {
                   sumH += heights[x];
                   count++;
               }
           }
           const avg = count > 0 ? sumH / count : 0;
           let deviation = 0;
           for (let x = 0; x < COLS; x++) {
               if (x !== targetWellCol) {
                   deviation += Math.abs(heights[x] - avg);
               }
           }
           score += weights.flatness * deviation;
        }
        
        return score;
      }

      // --- Rendering ---
      function render() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (board[y][x]) drawBlock(x, y, board[y][x]);
          }
        }

        // Ghost
        if (currentPiece && aiTarget) {
          let ghostY = currentPiece.y;
          while (
            !checkCollision(currentPiece.x, ghostY + 1, currentPiece.shape)
          )
            ghostY++;
          ctx.globalAlpha = 0.2;
          for (const [bx, by] of currentPiece.shape) {
            drawBlock(currentPiece.x + bx, ghostY + by, currentPiece.color);
          }
          ctx.globalAlpha = 1.0;
        }

        // Active
        if (currentPiece) {
          for (const [bx, by] of currentPiece.shape) {
            drawBlock(
              currentPiece.x + bx,
              currentPiece.y + by,
              currentPiece.color
            );
          }
        }

        // Scanlines
        ctx.fillStyle = "rgba(0,0,0,0.1)";
        for (let i = 0; i < canvas.height; i += 2)
          ctx.fillRect(0, i, canvas.width, 1);
      }

      function drawBlock(x, y, color) {
        const px = x * BLOCK_SIZE;
        const py = y * BLOCK_SIZE;
        ctx.fillStyle = color;
        ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);

        // Minimalist shading
        ctx.fillStyle = "rgba(0,0,0,0.1)"; // Border
        ctx.fillRect(px, py, BLOCK_SIZE, 1);
        ctx.fillRect(px, py, 1, BLOCK_SIZE);
        ctx.fillRect(px + BLOCK_SIZE - 1, py, 1, BLOCK_SIZE);
        ctx.fillRect(px, py + BLOCK_SIZE - 1, BLOCK_SIZE, 1);

        ctx.fillStyle = "rgba(255,255,255,0.15)"; // Shine
        ctx.fillRect(px + 2, py + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
      }

      // --- UI Updates ---
      function updateUI() {
        document.getElementById("scoreDisplay").innerText = score;
        document.getElementById("linesDisplay").innerText = lines;
        document.getElementById("levelDisplay").innerText = level;

        // Mobile updates
        document.getElementById("mobLevel").innerText = level;
        document.getElementById("mobLines").innerText = lines;
      }

      function updateQueueUI() {
        const qDiv = document.getElementById("visualQueue");
        const qCount = document.getElementById("queueCount");
        const emptyMsg = document.getElementById("emptyQueueMsg");

        if (pieceQueue.length === 0) {
          qCount.innerText = "0";
          emptyMsg.style.display = "block";
          qDiv.innerHTML = "";
          qDiv.appendChild(emptyMsg);
          return;
        }

        qCount.innerText = `${pieceQueue.length}`;
        emptyMsg.style.display = "none";
        qDiv.innerHTML = "";
        qDiv.appendChild(emptyMsg);

        pieceQueue.forEach((type) => {
          const el = document.createElement("div");
          el.className = "queue-item flex-shrink-0 bg-zinc-800 rounded-sm p-1";
          el.appendChild(createMiniGrid(type));
          qDiv.appendChild(el);
        });
      }

      function resetGame() {
        init();
      }

      window.addEventListener("keydown", (e) => {
        // Updated listener: handles case-insensitivity and works anywhere
        const key = e.key.toLowerCase();
        
        // Handle space pause
        if (e.key === " " || e.code === "Space") {
          e.preventDefault();
          togglePause();
          return;
        }

        // Find mapped type (check lower case key or direct key)
        const type = KEY_MAP[e.key] || KEY_MAP[key];
        
        if (type) {
          e.preventDefault(); // Prevent scrolling/select interaction
          addPiece(type);
          
          const btn = Array.from(document.querySelectorAll("button")).find(
            (b) => b.title.includes(type + " Piece")
          );
          if (btn) {
            btn.style.transform = "scale(0.96)";
            setTimeout(() => (btn.style.transform = ""), 100);
          }
        }
      }, { capture: true }); // Capture phase ensures this runs even if focus is in a weird spot

      // Boot
      initControls();
      init();
    </script>
  </body>
</html>
