<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Tetris but you are the RNG function</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap");

      :root {
        --bg-color: #050505;
        --panel-bg: #111;
        --accent: #333;
      }

      body {
        font-family: "JetBrains Mono", monospace;
        background-color: var(--bg-color);
        color: #a1a1aa;
        overflow: hidden; /* Prevent scrolling */
        touch-action: manipulation; /* Improves touch response */
      }

      /* --- RESPONSIVE CANVAS SCALING --- */
      /* The core logic: Height drives the size, Width follows aspect ratio */
      canvas {
        image-rendering: pixelated; /* Essential for sharp upscale */
        display: block;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);

        /* Mobile Default: Takes up roughly half height to leave room for UI */
        height: 55vh;
        width: auto;
        max-width: 90vw; /* Safety constraint */
      }

      /* Desktop: Go BIG. Fill vertical space. */
      @media (min-width: 768px) {
        canvas {
          height: 85vh;
          max-width: none;
        }
      }

      /* Minimal Scrollbar */
      .queue-scroll::-webkit-scrollbar {
        height: 4px;
      }
      .queue-scroll::-webkit-scrollbar-track {
        background: #000;
      }
      .queue-scroll::-webkit-scrollbar-thumb {
        background: #333;
        border-radius: 2px;
      }

      /* Button Styling */
      .btn-control {
        background-color: #1a1a1a;
        border: 1px solid #333;
        transition: all 0.05s ease;
        position: relative;
        overflow: hidden;
      }
      .btn-control:hover {
        background-color: #2a2a2a;
        border-color: #555;
      }
      .btn-control:active {
        transform: translateY(2px);
        background-color: #444;
      }

      /* Mini Grids for Queue & Buttons */
      .mini-grid {
        display: grid;
        gap: 2px;
        pointer-events: none;
      }
      .mini-cell {
        width: 100%;
        aspect-ratio: 1/1;
        border-radius: 1px;
      }

      .queue-item {
        animation: slideLeft 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }
      @keyframes slideLeft {
        from {
          transform: translateX(20px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      /* Utility to hide UI on very short screens */
      @media (max-height: 600px) and (orientation: landscape) {
        .mobile-hide-landscape {
          display: none;
        }
        body {
          flex-direction: row;
        }
        canvas {
          height: 90vh;
        }
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col md:flex-row items-center justify-center p-2 md:p-0 gap-4 md:gap-12"
  >
    <!-- Left: Game Area -->
    <div class="flex flex-col items-center relative shrink-0">
      <!-- Main Game View -->
      <div
        class="relative group border-2 border-zinc-800 bg-black p-1 rounded-sm"
      >
        <!-- FIXED: Canvas Resolution matches logic (10x20 blocks * 24px) -->
        <canvas id="gameCanvas" width="240" height="480"></canvas>

        <!-- Desktop Floating Stats (Hidden on Mobile) -->
        <div
          class="absolute top-4 -left-36 text-right hidden md:block w-32 pointer-events-none"
        >
          <h1
            class="text-2xl font-extrabold text-white leading-none mb-1 opacity-90"
          >
            TETRIS
          </h1>
          <h2 class="text-[10px] text-zinc-500 font-bold tracking-[0.2em] mb-8">
            YOU ARE THE RNG
          </h2>

          <div class="space-y-6">
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest mb-1"
              >
                Score
              </div>
              <div
                id="scoreDisplay"
                class="text-3xl text-white font-mono leading-none"
              >
                0
              </div>
            </div>
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest mb-1"
              >
                Lines
              </div>
              <div
                id="linesDisplay"
                class="text-3xl text-white font-mono leading-none"
              >
                0
              </div>
            </div>
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest mb-1"
              >
                Level
              </div>
              <div
                id="levelDisplay"
                class="text-3xl text-yellow-500 font-mono leading-none"
              >
                0
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Status Bar (Below canvas on mobile) -->
      <div
        id="gameStatus"
        class="mt-2 h-6 text-xs md:text-sm font-bold tracking-widest text-zinc-500 uppercase flex items-center gap-2"
      >
        WAITING FOR INPUT
      </div>
    </div>

    <!-- Right: Controls -->
    <!-- Expanded width on mobile to fill screen width -->
    <div
      class="flex flex-col w-full max-w-[90vw] md:max-w-xs gap-3 md:gap-4 mobile-hide-landscape"
    >
      <!-- Mobile Stats Header -->
      <div class="flex justify-between items-end px-1">
        <div class="flex gap-4 md:hidden text-xs font-mono">
          <div>
            <span class="text-zinc-600 font-bold">LVL</span>
            <span id="mobLevel" class="text-white text-lg">0</span>
          </div>
          <div>
            <span class="text-zinc-600 font-bold">LNS</span>
            <span id="mobLines" class="text-white text-lg">0</span>
          </div>
        </div>

        <div class="flex items-center gap-2 ml-auto">
          <label class="text-[10px] font-bold text-zinc-600 uppercase"
            >Level</label
          >
          <select
            id="startLevel"
            onchange="resetGame()"
            class="bg-zinc-900 border border-zinc-700 text-zinc-300 text-xs rounded px-2 py-1 outline-none focus:border-blue-500"
          >
            <option value="0">00</option>
            <option value="1">01</option>
            <option value="2">02</option>
            <option value="3">03</option>
            <option value="4">04</option>
            <option value="5">05</option>
            <option value="8">08</option>
            <option value="9">09</option>
          </select>
        </div>
      </div>

      <!-- Queue Display -->
      <div
        class="bg-[#111] border border-zinc-800 p-2 rounded-sm h-24 flex flex-col shadow-inner"
      >
        <div class="flex justify-between items-center mb-1 px-1">
          <span
            class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
            >Next</span
          >
          <span id="queueCount" class="text-[10px] text-zinc-600">0</span>
        </div>

        <div
          id="visualQueue"
          class="queue-scroll flex-1 flex gap-2 overflow-x-auto items-center px-1"
        >
          <div
            id="emptyQueueMsg"
            class="w-full text-center text-xs text-zinc-700 italic"
          >
            Tap blocks to fill queue
          </div>
        </div>
      </div>

      <!-- Input Grid -->
      <!-- Adjusted grid to be taller and more touch-friendly -->
      <div class="grid grid-cols-4 gap-2" id="controlsGrid">
        <!-- JS generates buttons -->
        <button
          onclick="resetGame()"
          class="col-start-4 row-start-2 h-14 md:h-16 rounded-sm border border-red-900/30 text-red-700 bg-[#150505] hover:bg-red-950/50 hover:text-red-500 font-bold text-[10px] uppercase transition-colors flex items-center justify-center"
        >
          RST
        </button>
      </div>
    </div>

    <script>
      /**
       * Tetris: You are the RNG
       */

      // --- Configuration ---
      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 24;
      const AI_THINK_DELAY = 50;

      // Base speeds (ms per tick)
      const SPEEDS = [200, 180, 160, 140, 120, 100, 80, 60, 40, 20];

      // --- Shapes & Colors ---
      const SHAPES = {
        I: {
          color: "#06b6d4",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [2, 0],
          ],
        },
        J: {
          color: "#3b82f6",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [1, 1],
          ],
        },
        L: {
          color: "#f97316",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [-1, 1],
          ],
        },
        O: {
          color: "#eab308",
          blocks: [
            [0, 0],
            [1, 0],
            [0, 1],
            [1, 1],
          ],
        },
        S: {
          color: "#22c55e",
          blocks: [
            [0, 0],
            [1, 0],
            [0, 1],
            [-1, 1],
          ],
        },
        T: {
          color: "#a855f7",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [0, 1],
          ],
        },
        Z: {
          color: "#ef4444",
          blocks: [
            [0, 0],
            [-1, 0],
            [0, 1],
            [1, 1],
          ],
        },
      };

      const KEY_MAP = {
        1: "I",
        2: "O",
        3: "T",
        4: "S",
        5: "Z",
        6: "J",
        7: "L",
        i: "I",
        o: "O",
        t: "T",
        s: "S",
        z: "Z",
        j: "J",
        l: "L",
      };

      // --- Game State ---
      let board = [];
      let pieceQueue = [];
      let currentPiece = null;
      let score = 0;
      let lines = 0;
      let level = 0;
      let startLevel = 0;
      let gameOver = false;
      let animationId = null;

      // AI State
      let aiTarget = null;
      let lastAiActionTime = 0;
      let isAiActing = false;

      // --- Canvas ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // --- Initialization ---
      function init() {
        if (animationId) cancelAnimationFrame(animationId);

        board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        pieceQueue = [];
        currentPiece = null;
        score = 0;
        lines = 0;
        gameOver = false;
        isAiActing = false;
        aiTarget = null;

        const select = document.getElementById("startLevel");
        startLevel = parseInt(select.value, 10);
        level = startLevel;

        updateUI();
        updateQueueUI();
        updateStatus("Waiting for Input");

        gameLoop();
      }

      function initControls() {
        const grid = document.getElementById("controlsGrid");
        const order = ["I", "O", "T", "S", "Z", "J", "L"];

        // Save Reset button logic
        const resetButton = grid.querySelector('button[onclick="resetGame()"]');
        grid.innerHTML = "";

        order.forEach((type) => {
          const btn = document.createElement("button");
          // Increased height for better touch targets
          btn.className =
            "btn-control h-14 md:h-16 rounded-sm relative flex items-center justify-center";
          btn.onclick = () => addPiece(type);
          // Prevent zoom on double tap
          btn.ondblclick = (e) => e.preventDefault();

          const mini = createMiniGrid(type);
          // Make mini grid fill about 50% of button width
          mini.style.width = "40%";
          btn.appendChild(mini);

          grid.appendChild(btn);
        });

        if (resetButton) grid.appendChild(resetButton);
      }

      function createMiniGrid(type) {
        const shape = SHAPES[type];
        const wrapper = document.createElement("div");
        wrapper.className = "mini-grid";

        const w = 4;
        // h not strictly needed for grid-template but helps calc

        wrapper.style.gridTemplateColumns = `repeat(${w}, 1fr)`;

        const gridMap = Array(w * 2).fill(0);

        let offsetX = 1;
        let offsetY = 0;
        if (type === "I") {
          offsetX = 1;
          offsetY = 0;
        } // Center in 4-wide

        shape.blocks.forEach(([x, y]) => {
          const gx = x + offsetX;
          const gy = y + offsetY;
          const idx = gy * w + gx;
          if (idx >= 0 && idx < gridMap.length) {
            gridMap[idx] = 1;
          }
        });

        gridMap.forEach((active) => {
          const cell = document.createElement("div");
          cell.className = "mini-cell";
          if (active) {
            cell.style.backgroundColor = shape.color;
            cell.style.boxShadow = "inset 0 0 2px rgba(0,0,0,0.5)";
          } else {
            cell.style.backgroundColor = "transparent";
          }
          wrapper.appendChild(cell);
        });

        return wrapper;
      }

      // --- Logic ---

      function addPiece(type) {
        if (gameOver) init();
        pieceQueue.push(type);
        updateQueueUI();
      }

      function updateStatus(msg, colorClass = "text-zinc-500") {
        const el = document.getElementById("gameStatus");
        el.innerHTML = msg;
        el.className = `h-6 text-xs md:text-sm font-bold tracking-widest uppercase flex items-center gap-2 ${colorClass}`;
      }

      function gameLoop(time = 0) {
        if (gameOver) return;

        if (!currentPiece && !isAiActing) {
          if (pieceQueue.length > 0) {
            spawnPiece();
          } else {
            updateStatus("Waiting for Input");
          }
        }

        if (currentPiece && isAiActing && aiTarget) {
          const speedIndex = Math.min(level, SPEEDS.length - 1);
          const interval = SPEEDS[speedIndex];

          if (time - lastAiActionTime > interval) {
            performAiStep();
            lastAiActionTime = time;
          }
        }

        render();
        animationId = requestAnimationFrame(gameLoop);
      }

      function spawnPiece() {
        const type = pieceQueue.shift();
        updateQueueUI();

        updateStatus(
          `Processing <span style="color:${SHAPES[type].color}">${type}</span>...`,
          "text-zinc-300"
        );

        currentPiece = {
          type: type,
          x: 4,
          y: 0,
          shape: JSON.parse(JSON.stringify(SHAPES[type].blocks)),
          rotationState: 0,
          color: SHAPES[type].color,
        };

        if (
          checkCollision(currentPiece.x, currentPiece.y, currentPiece.shape)
        ) {
          gameOver = true;
          updateStatus("Game Over", "text-red-500");
          return;
        }

        setTimeout(() => {
          const move = findBestMove(board, currentPiece);
          if (move) {
            aiTarget = move;
            isAiActing = true;
          } else {
            aiTarget = { x: currentPiece.x, rotation: 0 };
            isAiActing = true;
          }
        }, AI_THINK_DELAY);
      }

      function performAiStep() {
        if (!currentPiece) return;

        if (currentPiece.rotationState !== aiTarget.rotation) {
          const rotated = rotatePiece(currentPiece);
          if (rotated) {
            currentPiece.rotationState = (currentPiece.rotationState + 1) % 4;
          }
          return;
        }

        if (currentPiece.x !== aiTarget.x) {
          const direction = aiTarget.x > currentPiece.x ? 1 : -1;
          if (
            !checkCollision(
              currentPiece.x + direction,
              currentPiece.y,
              currentPiece.shape
            )
          ) {
            currentPiece.x += direction;
            return;
          }
        }

        if (
          !checkCollision(
            currentPiece.x,
            currentPiece.y + 1,
            currentPiece.shape
          )
        ) {
          currentPiece.y++;
        } else {
          lockPiece();
        }
      }

      function rotatePiece(piece) {
        const newShape = piece.shape.map(([x, y]) => [-y, x]);
        if (checkCollision(piece.x, piece.y, newShape)) {
          if (!checkCollision(piece.x - 1, piece.y, newShape)) piece.x -= 1;
          else if (!checkCollision(piece.x + 1, piece.y, newShape))
            piece.x += 1;
          else return false;
        }
        piece.shape = newShape;
        return true;
      }

      function checkCollision(x, y, shape, testBoard = board) {
        for (const [bx, by] of shape) {
          const nx = x + bx;
          const ny = y + by;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (ny >= 0 && testBoard[ny][nx]) return true;
        }
        return false;
      }

      function lockPiece() {
        for (const [bx, by] of currentPiece.shape) {
          const ny = currentPiece.y + by;
          const nx = currentPiece.x + bx;
          if (ny >= 0) {
            board[ny][nx] = currentPiece.color;
          }
        }
        clearLines();
        currentPiece = null;
        isAiActing = false;
        aiTarget = null;
      }

      function clearLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every((cell) => cell !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++;
          }
        }
        if (linesCleared > 0) {
          lines += linesCleared;
          const multipliers = [0, 40, 100, 300, 1200];
          score += multipliers[linesCleared] * (level + 1);

          const oldLevel = level;
          level = startLevel + Math.floor(lines / 10);

          updateUI();
        }
      }

      // --- AI Evaluation ---
      const WEIGHTS = {
        aggregateHeight: -0.51,
        completeLines: 0.76,
        holes: -0.36,
        bumpiness: -0.18,
      };

      function findBestMove(grid, piece) {
        let bestScore = -Infinity;
        let bestMove = null;
        const rotations = piece.type === "O" ? 1 : 4;

        for (let r = 0; r < rotations; r++) {
          let shape = JSON.parse(JSON.stringify(piece.shape));
          for (let i = 0; i < r; i++) shape = shape.map(([x, y]) => [-y, x]);

          for (let x = -3; x < COLS + 3; x++) {
            if (!checkCollision(x, 0, shape, grid)) {
              let y = 0;
              while (!checkCollision(x, y + 1, shape, grid)) y++;

              const tempGrid = grid.map((row) => [...row]);
              let validLock = true;
              for (const [bx, by] of shape) {
                const ny = y + by;
                const nx = x + bx;
                if (ny < 0 || ny >= ROWS || nx < 0 || nx >= COLS)
                  validLock = false;
                else tempGrid[ny][nx] = 1;
              }

              if (validLock) {
                const s = evaluateGrid(tempGrid);
                if (s > bestScore) {
                  bestScore = s;
                  bestMove = { rotation: r, x: x };
                }
              }
            }
          }
        }
        return bestMove;
      }

      function evaluateGrid(grid) {
        let aggH = 0,
          lines = 0,
          holes = 0,
          bump = 0;
        const heights = new Array(COLS).fill(0);

        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS; y++) {
            if (grid[y][x] !== 0) {
              heights[x] = ROWS - y;
              break;
            }
          }
        }
        aggH = heights.reduce((a, b) => a + b, 0);

        for (let y = 0; y < ROWS; y++) {
          if (grid[y].every((c) => c !== 0)) lines++;
        }

        for (let x = 0; x < COLS; x++) {
          let block = false;
          for (let y = 0; y < ROWS; y++) {
            if (grid[y][x] !== 0) block = true;
            else if (block && grid[y][x] === 0) holes++;
          }
        }

        for (let x = 0; x < COLS - 1; x++)
          bump += Math.abs(heights[x] - heights[x + 1]);

        return (
          WEIGHTS.aggregateHeight * aggH +
          WEIGHTS.completeLines * lines +
          WEIGHTS.holes * holes +
          WEIGHTS.bumpiness * bump
        );
      }

      // --- Rendering ---
      function render() {
        ctx.fillStyle = "#050505";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (board[y][x]) drawBlock(x, y, board[y][x]);
          }
        }

        if (currentPiece && aiTarget) {
          let ghostY = currentPiece.y;
          while (
            !checkCollision(currentPiece.x, ghostY + 1, currentPiece.shape)
          )
            ghostY++;
          ctx.globalAlpha = 0.15;
          for (const [bx, by] of currentPiece.shape) {
            drawBlock(currentPiece.x + bx, ghostY + by, currentPiece.color);
          }
          ctx.globalAlpha = 1.0;
        }

        if (currentPiece) {
          for (const [bx, by] of currentPiece.shape) {
            drawBlock(
              currentPiece.x + bx,
              currentPiece.y + by,
              currentPiece.color
            );
          }
        }

        ctx.fillStyle = "rgba(0,0,0,0.15)";
        for (let i = 0; i < canvas.height; i += 2)
          ctx.fillRect(0, i, canvas.width, 1);
      }

      function drawBlock(x, y, color) {
        const px = x * BLOCK_SIZE;
        const py = y * BLOCK_SIZE;

        // Fill
        ctx.fillStyle = color;
        ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);

        // Inner Shadow (Simulate bevel)
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(px + BLOCK_SIZE - 2, py, 2, BLOCK_SIZE);
        ctx.fillRect(px, py + BLOCK_SIZE - 2, BLOCK_SIZE, 2);

        // Highlight
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(px, py, BLOCK_SIZE, 2);
        ctx.fillRect(px, py, 2, BLOCK_SIZE);
      }

      // --- UI Updates ---
      function updateUI() {
        document.getElementById("scoreDisplay").innerText = score;
        document.getElementById("linesDisplay").innerText = lines;
        document.getElementById("levelDisplay").innerText = level;

        document.getElementById("mobLevel").innerText = level;
        document.getElementById("mobLines").innerText = lines;
      }

      function updateQueueUI() {
        const qDiv = document.getElementById("visualQueue");
        const qCount = document.getElementById("queueCount");
        const emptyMsg = document.getElementById("emptyQueueMsg");

        if (pieceQueue.length === 0) {
          qCount.innerText = "0";
          emptyMsg.style.display = "block";
          qDiv.innerHTML = "";
          qDiv.appendChild(emptyMsg);
          return;
        }

        qCount.innerText = `${pieceQueue.length}`;
        emptyMsg.style.display = "none";
        qDiv.innerHTML = "";
        qDiv.appendChild(emptyMsg);

        pieceQueue.forEach((type) => {
          const el = document.createElement("div");
          el.className =
            "queue-item flex-shrink-0 bg-[#1a1a1a] rounded-sm p-1 w-8 h-8 flex items-center justify-center";
          const mini = createMiniGrid(type);
          el.appendChild(mini);
          qDiv.appendChild(el);
        });
      }

      function resetGame() {
        init();
      }

      window.addEventListener("keydown", (e) => {
        if (KEY_MAP[e.key]) {
          addPiece(KEY_MAP[e.key]);
          const btn = Array.from(document.querySelectorAll("button")).find(
            (b) => b.onclick.toString().includes(KEY_MAP[e.key])
          );
          if (btn) {
            btn.style.transform = "scale(0.96)";
            setTimeout(() => (btn.style.transform = ""), 100);
          }
        }
      });

      initControls();
      init();
    </script>
  </body>
</html>
