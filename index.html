<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris but you are the RNG function</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap");

      body {
        font-family: "JetBrains Mono", monospace;
        background-color: #09090b; /* Zinc 950 */
        color: #a1a1aa; /* Zinc 400 */
        overflow: hidden; /* Prevent scrolling */
      }

      /* Fix for Canvas Scaling/Blurring 
           We set the display size explicitly via CSS to match aspect ratio
           and ensure it doesn't overflow containers.
        */
      canvas {
        image-rendering: pixelated;
        max-width: 100%;
        max-height: 80vh; /* Ensure it fits vertically on mobile */
        width: auto;
        height: auto;
        display: block;
      }

      .queue-scroll::-webkit-scrollbar {
        height: 4px;
      }
      .queue-scroll::-webkit-scrollbar-track {
        background: #18181b;
      }
      .queue-scroll::-webkit-scrollbar-thumb {
        background: #3f3f46;
        border-radius: 2px;
      }

      /* Button Styling */
      .btn-control {
        background-color: #18181b;
        border: 1px solid #27272a;
        transition: all 0.1s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }
      .btn-control:hover {
        background-color: #27272a;
        border-color: #52525b;
      }
      .btn-control:active {
        transform: scale(0.96);
      }

      /* Mini Grids for Queue & Buttons */
      .mini-grid {
        display: grid;
        gap: 1px;
        pointer-events: none; /* Let clicks pass to button */
      }
      .mini-cell {
        width: 6px;
        height: 6px;
        border-radius: 1px;
      }
      /* Mobile adjustment for tiny cells */
      @media (min-width: 768px) {
        .mini-cell {
          width: 8px;
          height: 8px;
        }
      }

      .queue-item {
        animation: slideLeft 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }
      @keyframes slideLeft {
        from {
          transform: translateX(20px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body
    class="h-screen w-screen flex flex-col md:flex-row items-center justify-center p-4 md:p-6 gap-6 md:gap-12"
  >
    <!-- Left: Game Area -->
    <div class="flex flex-col items-center gap-4 shrink-0">
      <!-- Header for Mobile -->
      <h1
        class="md:hidden text-xs font-bold text-zinc-500 tracking-widest uppercase"
      >
        Tetris but you are the RNG
      </h1>

      <div class="relative group">
        <!-- Canvas Container with specific border sizing -->
        <div
          class="border-2 border-zinc-800 p-1 bg-zinc-900 shadow-2xl rounded-sm"
        >
          <!-- FIXED: Height increased to 480 to match 20 rows * 24px -->
          <canvas
            id="gameCanvas"
            width="240"
            height="480"
            class="bg-black"
          ></canvas>
        </div>

        <!-- Stats Panel (Desktop) -->
        <div class="absolute top-0 -left-32 text-right hidden md:block w-28">
          <div class="mb-6">
            <h1 class="text-sm font-bold text-zinc-300 leading-tight mb-1">
              TETRIS<br /><span class="text-xs text-zinc-600 font-normal"
                >BUT YOU ARE THE RNG FUNCTION</span
              >
            </h1>
          </div>

          <div class="space-y-4">
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
              >
                Score
              </div>
              <div id="scoreDisplay" class="text-xl text-white font-mono">
                0
              </div>
            </div>
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
              >
                Lines
              </div>
              <div id="linesDisplay" class="text-xl text-white font-mono">
                0
              </div>
            </div>
            <div>
              <div
                class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
              >
                Level
              </div>
              <div id="levelDisplay" class="text-xl text-yellow-500 font-mono">
                0
              </div>
            </div>
          </div>
        </div>
      </div>

      <div
        id="gameStatus"
        class="h-6 text-sm font-bold tracking-widest text-zinc-500 uppercase flex items-center gap-2"
      >
        WAITING FOR INPUT
      </div>
    </div>

    <!-- Right: Controls -->
    <div class="flex flex-col w-full max-w-sm gap-4">
      <!-- Level Select & Mobile Stats -->
      <div class="flex justify-between items-end">
        <!-- Mobile Stats -->
        <div class="flex gap-4 md:hidden text-xs">
          <div>
            <span class="text-zinc-600">LVL</span>
            <span id="mobLevel" class="text-white">0</span>
          </div>
          <div>
            <span class="text-zinc-600">LNS</span>
            <span id="mobLines" class="text-white">0</span>
          </div>
        </div>

        <div class="flex items-center gap-2 ml-auto">
          <label class="text-[10px] font-bold text-zinc-600 uppercase"
            >Start Level</label
          >
          <select
            id="startLevel"
            onchange="resetGame()"
            class="bg-zinc-900 border border-zinc-700 text-zinc-300 text-xs rounded px-2 py-1 outline-none focus:border-blue-500"
          >
            <option value="0">00</option>
            <option value="1">01</option>
            <option value="2">02</option>
            <option value="3">03</option>
            <option value="4">04</option>
            <option value="5">05</option>
            <option value="6">06</option>
            <option value="7">07</option>
            <option value="8">08</option>
            <option value="9">09</option>
          </select>
        </div>
      </div>

      <!-- Queue Display -->
      <div
        class="bg-zinc-900/80 border border-zinc-800 p-3 rounded-sm h-28 flex flex-col shadow-inner"
      >
        <div class="flex justify-between items-center mb-2">
          <span
            class="text-[10px] font-bold text-zinc-600 uppercase tracking-widest"
            >Next Queue</span
          >
          <span id="queueCount" class="text-[10px] text-zinc-500">0</span>
        </div>

        <div
          id="visualQueue"
          class="queue-scroll flex-1 flex gap-3 overflow-x-auto items-center px-1"
        >
          <div
            id="emptyQueueMsg"
            class="w-full text-center text-xs text-zinc-700 italic"
          >
            Tap buttons below...
          </div>
        </div>
      </div>

      <!-- Input Grid -->
      <div class="grid grid-cols-4 gap-2" id="controlsGrid">
        <!-- Buttons generated by JS to ensure visual consistency -->
        <button
          onclick="resetGame()"
          class="col-start-4 row-start-2 h-full rounded-sm border border-red-900/30 text-red-800 hover:bg-red-950/50 hover:text-red-500 font-bold text-[10px] uppercase transition-colors flex items-center justify-center"
        >
          RST
        </button>
      </div>

      <div class="text-center text-[10px] text-zinc-700 mt-2">
        AI plays automatically using your pieces
      </div>
    </div>

    <script>
      /**
       * Tetris: You are the RNG
       * * Updates:
       * - Fixed canvas scaling with CSS max-width/height logic.
       * - Unified 'MiniGrid' renderer for both buttons and queue items.
       * - Added Leveling system (Speed increases with level).
       * - Added Start Level selector.
       * - FIXED: Canvas height set to 480 to prevent invisible rows.
       * - FIXED: Reset logic correctly cancels old animation loops.
       * - FIXED: Syntax error in initControls
       */

      // --- Configuration ---
      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 24;
      const AI_THINK_DELAY = 50;

      // Base speeds (ms per tick) mimicking NES curve somewhat adapted for AI animation
      // Level 0 is slow-ish, Level 9 is very snappy.
      const SPEEDS = [
        200, // Lvl 0
        180, // Lvl 1
        160, // Lvl 2
        140, // Lvl 3
        120, // Lvl 4
        100, // Lvl 5
        80, // Lvl 6
        60, // Lvl 7
        40, // Lvl 8
        20, // Lvl 9 (Hyper)
      ];

      // --- Shapes & Colors ---
      const SHAPES = {
        I: {
          color: "#06b6d4",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [2, 0],
          ],
          width: 4,
          height: 1,
        }, // Cyan (Tailwind cyan-500)
        J: {
          color: "#3b82f6",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [1, 1],
          ],
          width: 3,
          height: 2,
        }, // Blue (blue-500)
        L: {
          color: "#f97316",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [-1, 1],
          ],
          width: 3,
          height: 2,
        }, // Orange (orange-500)
        O: {
          color: "#eab308",
          blocks: [
            [0, 0],
            [1, 0],
            [0, 1],
            [1, 1],
          ],
          width: 2,
          height: 2,
        }, // Yellow (yellow-500)
        S: {
          color: "#22c55e",
          blocks: [
            [0, 0],
            [1, 0],
            [0, 1],
            [-1, 1],
          ],
          width: 3,
          height: 2,
        }, // Green (green-500)
        T: {
          color: "#a855f7",
          blocks: [
            [0, 0],
            [-1, 0],
            [1, 0],
            [0, 1],
          ],
          width: 3,
          height: 2,
        }, // Purple (purple-500)
        Z: {
          color: "#ef4444",
          blocks: [
            [0, 0],
            [-1, 0],
            [0, 1],
            [1, 1],
          ],
          width: 3,
          height: 2,
        }, // Red (red-500)
      };

      const KEY_MAP = {
        1: "I",
        2: "O",
        3: "T",
        4: "S",
        5: "Z",
        6: "J",
        7: "L",
        i: "I",
        o: "O",
        t: "T",
        s: "S",
        z: "Z",
        j: "J",
        l: "L",
      };

      // --- Game State ---
      let board = [];
      let pieceQueue = [];
      let currentPiece = null;
      let score = 0;
      let lines = 0;
      let level = 0;
      let startLevel = 0;
      let gameOver = false;
      let animationId = null;

      // AI State
      let aiTarget = null;
      let lastAiActionTime = 0;
      let isAiActing = false;

      // --- Canvas ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // --- Initialization ---
      function init() {
        // Cancel old loop if exists
        if (animationId) cancelAnimationFrame(animationId);

        // Reset core vars
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        pieceQueue = [];
        currentPiece = null;
        score = 0;
        lines = 0;
        gameOver = false;
        isAiActing = false;
        aiTarget = null;

        // Get start level
        const select = document.getElementById("startLevel");
        startLevel = parseInt(select.value, 10);
        level = startLevel;

        updateUI();
        updateQueueUI();
        updateStatus("Waiting for Input");

        // Start loop
        gameLoop();
      }

      // Generate the control buttons dynamically
      function initControls() {
        const grid = document.getElementById("controlsGrid");
        // Order: I, O, T, S | Z, J, L
        const order = ["I", "O", "T", "S", "Z", "J", "L"];

        // Clear existing but keep the Reset button (which is manually placed at end)
        const resetButton = grid.querySelector('button[onclick="resetGame()"]');
        grid.innerHTML = "";

        order.forEach((type) => {
          const btn = document.createElement("button");
          btn.className = "btn-control h-12 md:h-14 rounded-sm relative";
          btn.onclick = () => addPiece(type);
          btn.title = `Add ${type} Piece`;

          // Append the mini grid visual
          btn.appendChild(createMiniGrid(type));

          grid.appendChild(btn);
        });

        // Re-add reset button at the end
        if (resetButton) grid.appendChild(resetButton);
      }

      // Helper to create HTML representation of a piece
      function createMiniGrid(type) {
        const shape = SHAPES[type];
        const wrapper = document.createElement("div");
        wrapper.className = "mini-grid";

        // Calculate grid dimensions based on shape
        // Center the piece in a 4x2 or 4x3 grid
        const w = 4;
        const h = type === "I" ? 1 : 2; // flatten for button

        wrapper.style.gridTemplateColumns = `repeat(${w}, 1fr)`;

        // Create a 4xN grid map
        const gridMap = Array(w * 2).fill(0); // ample space

        // Map blocks to the grid. Offset to center.
        // Base offsets to make them look nice in the button
        let offsetX = 1;
        let offsetY = 0;

        // FIXED: I-piece was previously offset to 0, which clipped the block at x=-1.
        // Now it uses the default offsetX=1, shifting the range [-1, 2] to [0, 3].
        if (type === "I") {
          offsetX = 1;
          offsetY = 0;
        }
        if (type === "O") {
          offsetX = 1;
          offsetY = 0;
        }
        if (
          type === "T" ||
          type === "S" ||
          type === "Z" ||
          type === "J" ||
          type === "L"
        ) {
          offsetX = 1;
          offsetY = 0;
        }

        shape.blocks.forEach(([x, y]) => {
          // block coords are relative to pivot (0,0)
          // map to flat array index
          const gx = x + offsetX;
          const gy = y + offsetY;
          const idx = gy * w + gx;
          if (idx >= 0 && idx < gridMap.length) {
            gridMap[idx] = 1;
          }
        });

        // Build DOM
        gridMap.forEach((active) => {
          const cell = document.createElement("div");
          cell.className = "mini-cell";
          if (active) {
            cell.style.backgroundColor = shape.color;
            cell.style.boxShadow = "inset 0 0 2px rgba(0,0,0,0.3)";
          } else {
            cell.style.backgroundColor = "transparent";
          }
          wrapper.appendChild(cell);
        });

        return wrapper;
      }

      // --- Logic ---

      function addPiece(type) {
        if (gameOver) init();
        pieceQueue.push(type);
        updateQueueUI();
      }

      function updateStatus(msg, colorClass = "text-zinc-500") {
        const el = document.getElementById("gameStatus");
        el.innerHTML = msg;
        el.className = `h-6 text-sm font-bold tracking-widest uppercase flex items-center gap-2 ${colorClass}`;
      }

      // Main Game Loop
      function gameLoop(time = 0) {
        if (gameOver) return;

        // 1. Spawning
        if (!currentPiece && !isAiActing) {
          if (pieceQueue.length > 0) {
            spawnPiece();
          } else {
            updateStatus("Waiting for Input");
          }
        }

        // 2. AI Animation/Logic
        if (currentPiece && isAiActing && aiTarget) {
          // Determine speed based on level (clamped to max index)
          const speedIndex = Math.min(level, SPEEDS.length - 1);
          const interval = SPEEDS[speedIndex];

          if (time - lastAiActionTime > interval) {
            performAiStep();
            lastAiActionTime = time;
          }
        }

        // 3. Render
        render();
        animationId = requestAnimationFrame(gameLoop);
      }

      function spawnPiece() {
        const type = pieceQueue.shift();
        updateQueueUI();

        updateStatus(
          `Processing <span style="color:${SHAPES[type].color}">${type}</span>...`,
          "text-zinc-300"
        );

        currentPiece = {
          type: type,
          x: 4,
          y: 0,
          shape: JSON.parse(JSON.stringify(SHAPES[type].blocks)),
          rotationState: 0,
          color: SHAPES[type].color,
        };

        if (
          checkCollision(currentPiece.x, currentPiece.y, currentPiece.shape)
        ) {
          gameOver = true;
          updateStatus("Game Over", "text-red-500");
          return;
        }

        setTimeout(() => {
          const move = findBestMove(board, currentPiece);
          if (move) {
            aiTarget = move;
            isAiActing = true;
          } else {
            aiTarget = { x: currentPiece.x, rotation: 0 };
            isAiActing = true;
          }
        }, AI_THINK_DELAY);
      }

      function performAiStep() {
        if (!currentPiece) return;

        // Rotation
        if (currentPiece.rotationState !== aiTarget.rotation) {
          const rotated = rotatePiece(currentPiece);
          if (rotated) {
            currentPiece.rotationState = (currentPiece.rotationState + 1) % 4;
          } else {
            // If rotation failed (blocked), force skip to X movement to prevent infinite loop
            // In a real scenario, this means AI plan is invalid, but we just fall through
          }
          return;
        }

        // X Movement
        if (currentPiece.x !== aiTarget.x) {
          const direction = aiTarget.x > currentPiece.x ? 1 : -1;
          if (
            !checkCollision(
              currentPiece.x + direction,
              currentPiece.y,
              currentPiece.shape
            )
          ) {
            currentPiece.x += direction;
            return;
          }
        }

        // Drop
        if (
          !checkCollision(
            currentPiece.x,
            currentPiece.y + 1,
            currentPiece.shape
          )
        ) {
          currentPiece.y++;
        } else {
          lockPiece();
        }
      }

      function rotatePiece(piece) {
        const newShape = piece.shape.map(([x, y]) => [-y, x]);
        // Wall kick
        if (checkCollision(piece.x, piece.y, newShape)) {
          if (!checkCollision(piece.x - 1, piece.y, newShape)) piece.x -= 1;
          else if (!checkCollision(piece.x + 1, piece.y, newShape))
            piece.x += 1;
          else return false; // Fail
        }
        piece.shape = newShape;
        return true; // Success
      }

      function checkCollision(x, y, shape, testBoard = board) {
        for (const [bx, by] of shape) {
          const nx = x + bx;
          const ny = y + by;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (ny >= 0 && testBoard[ny][nx]) return true;
        }
        return false;
      }

      function lockPiece() {
        for (const [bx, by] of currentPiece.shape) {
          const ny = currentPiece.y + by;
          const nx = currentPiece.x + bx;
          if (ny >= 0) {
            board[ny][nx] = currentPiece.color;
          }
        }
        clearLines();
        currentPiece = null;
        isAiActing = false;
        aiTarget = null;
      }

      function clearLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every((cell) => cell !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++;
          }
        }
        if (linesCleared > 0) {
          lines += linesCleared;
          // Standard NES scoring
          const multipliers = [0, 40, 100, 300, 1200];
          score += multipliers[linesCleared] * (level + 1);

          // Level up logic (every 10 lines)
          const oldLevel = level;
          level = startLevel + Math.floor(lines / 10);

          updateUI();
        }
      }

      // --- AI Evaluation ---
      const WEIGHTS = {
        aggregateHeight: -0.51,
        completeLines: 0.76,
        holes: -0.36,
        bumpiness: -0.18,
      };

      function findBestMove(grid, piece) {
        let bestScore = -Infinity;
        let bestMove = null;
        const rotations = piece.type === "O" ? 1 : 4;

        for (let r = 0; r < rotations; r++) {
          let shape = JSON.parse(JSON.stringify(piece.shape));
          for (let i = 0; i < r; i++) shape = shape.map(([x, y]) => [-y, x]);

          for (let x = -3; x < COLS + 3; x++) {
            if (!checkCollision(x, 0, shape, grid)) {
              let y = 0;
              while (!checkCollision(x, y + 1, shape, grid)) y++;

              const tempGrid = grid.map((row) => [...row]);
              let validLock = true;
              for (const [bx, by] of shape) {
                const ny = y + by;
                const nx = x + bx;
                if (ny < 0 || ny >= ROWS || nx < 0 || nx >= COLS)
                  validLock = false;
                else tempGrid[ny][nx] = 1;
              }

              if (validLock) {
                const s = evaluateGrid(tempGrid);
                if (s > bestScore) {
                  bestScore = s;
                  bestMove = { rotation: r, x: x };
                }
              }
            }
          }
        }
        return bestMove;
      }

      function evaluateGrid(grid) {
        let aggH = 0,
          lines = 0,
          holes = 0,
          bump = 0;
        const heights = new Array(COLS).fill(0);

        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS; y++) {
            if (grid[y][x] !== 0) {
              heights[x] = ROWS - y;
              break;
            }
          }
        }
        aggH = heights.reduce((a, b) => a + b, 0);

        for (let y = 0; y < ROWS; y++) {
          if (grid[y].every((c) => c !== 0)) lines++;
        }

        for (let x = 0; x < COLS; x++) {
          let block = false;
          for (let y = 0; y < ROWS; y++) {
            if (grid[y][x] !== 0) block = true;
            else if (block && grid[y][x] === 0) holes++;
          }
        }

        for (let x = 0; x < COLS - 1; x++)
          bump += Math.abs(heights[x] - heights[x + 1]);

        return (
          WEIGHTS.aggregateHeight * aggH +
          WEIGHTS.completeLines * lines +
          WEIGHTS.holes * holes +
          WEIGHTS.bumpiness * bump
        );
      }

      // --- Rendering ---
      function render() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (board[y][x]) drawBlock(x, y, board[y][x]);
          }
        }

        // Ghost
        if (currentPiece && aiTarget) {
          let ghostY = currentPiece.y;
          while (
            !checkCollision(currentPiece.x, ghostY + 1, currentPiece.shape)
          )
            ghostY++;
          ctx.globalAlpha = 0.2;
          for (const [bx, by] of currentPiece.shape) {
            drawBlock(currentPiece.x + bx, ghostY + by, currentPiece.color);
          }
          ctx.globalAlpha = 1.0;
        }

        // Active
        if (currentPiece) {
          for (const [bx, by] of currentPiece.shape) {
            drawBlock(
              currentPiece.x + bx,
              currentPiece.y + by,
              currentPiece.color
            );
          }
        }

        // Scanlines
        ctx.fillStyle = "rgba(0,0,0,0.1)";
        for (let i = 0; i < canvas.height; i += 2)
          ctx.fillRect(0, i, canvas.width, 1);
      }

      function drawBlock(x, y, color) {
        const px = x * BLOCK_SIZE;
        const py = y * BLOCK_SIZE;
        ctx.fillStyle = color;
        ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);

        // Minimalist shading
        ctx.fillStyle = "rgba(0,0,0,0.1)"; // Border
        ctx.fillRect(px, py, BLOCK_SIZE, 1);
        ctx.fillRect(px, py, 1, BLOCK_SIZE);
        ctx.fillRect(px + BLOCK_SIZE - 1, py, 1, BLOCK_SIZE);
        ctx.fillRect(px, py + BLOCK_SIZE - 1, BLOCK_SIZE, 1);

        ctx.fillStyle = "rgba(255,255,255,0.15)"; // Shine
        ctx.fillRect(px + 2, py + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
      }

      // --- UI Updates ---
      function updateUI() {
        document.getElementById("scoreDisplay").innerText = score;
        document.getElementById("linesDisplay").innerText = lines;
        document.getElementById("levelDisplay").innerText = level;

        // Mobile updates
        document.getElementById("mobLevel").innerText = level;
        document.getElementById("mobLines").innerText = lines;
      }

      function updateQueueUI() {
        const qDiv = document.getElementById("visualQueue");
        const qCount = document.getElementById("queueCount");
        const emptyMsg = document.getElementById("emptyQueueMsg");

        if (pieceQueue.length === 0) {
          qCount.innerText = "0";
          emptyMsg.style.display = "block";
          qDiv.innerHTML = "";
          qDiv.appendChild(emptyMsg);
          return;
        }

        qCount.innerText = `${pieceQueue.length}`;
        emptyMsg.style.display = "none";
        qDiv.innerHTML = "";
        qDiv.appendChild(emptyMsg);

        pieceQueue.forEach((type) => {
          const el = document.createElement("div");
          el.className = "queue-item flex-shrink-0 bg-zinc-800 rounded-sm p-1";
          el.appendChild(createMiniGrid(type));
          qDiv.appendChild(el);
        });
      }

      function resetGame() {
        init();
      }

      window.addEventListener("keydown", (e) => {
        if (KEY_MAP[e.key]) {
          addPiece(KEY_MAP[e.key]);
          const btn = Array.from(document.querySelectorAll("button")).find(
            (b) => b.title.includes(KEY_MAP[e.key] + " Piece")
          );
          if (btn) {
            btn.style.transform = "scale(0.96)";
            setTimeout(() => (btn.style.transform = ""), 100);
          }
        }
      });

      // Boot
      initControls();
      init();
    </script>
  </body>
</html>
